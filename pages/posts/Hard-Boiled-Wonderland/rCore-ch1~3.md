---
title: rCore Ch1~Ch3笔记
author: OceanPresent
time: '2023-10-28'
lang: zh-CN
---

[[toc]]
# rCore Ch1~Ch3

## 执行环境和平台支持

![](http://res.oceanpresent.art/blog/202310292343505.png)
应用程序执行环境栈：图中的白色块自上而下表示各级执行环境，黑色块则表示相邻两层执行环境之间的接口。 下层作为上层的执行环境，支持上层代码运行。

编译器在编译、链接得到可执行文件时需要知道，程序要在哪个 **平台** (Platform) 上运行， **目标三元组** (Target Triplet) 描述了目标平台的 CPU 指令集、操作系统类型和标准运行时库。

例如：`x86_64-unknown-linux-gnu`表明 CPU 架构是 x86_64，CPU 厂商是 unknown，操作系统是 linux，运行时库是 gnu libc。elf表示没有标准运行时库

确实没有编程语言的标准库 std，也不存在任何受 OS 支持的系统调用。 这样的平台被我们称为 **裸机平台** (bare-metal)。对于Rust，还有一个不需要任何操作系统支持的核心库 core

编译器运行的平台（x86_64）与可执行文件运行的目标平台不同的情况，称为 **交叉编译** (Cross Compile)。

### 链接器

汇编语言链接器的作用是将多个汇编语言源文件合成为一个可执行文件。链接器会将每个源文件中的目标代码和库函数代码合并成一个可执行文件，以便程序可以在计算机上运行。链接器还有处理程序中的符号引用，分配内存空间等功能，确保程序在运行时能够正确地访问所有的代码和数据。

### 汇编知识

.section：这个指令用于指定接下来的代码或数据应该被放置在哪个section（段）中。

.global：这个指令用于声明一个全局的符号（比如函数或者变量），使得这个符号在整个程序中都可以被访问到。例如，你可能会在.global后面跟上一个函数名，来声明这个函数是全局可访问的。

### 在 RISC-V 架构上，调用者保存和被调用者保存寄存器如何划分的？

主要还是根据 调用规范（Calling Convention）
a0~a7（x10~x17）， 用来传递输入参数， 其中的 a0 和 a1 还用来保存返回值。 调用者保存。
t0~t6(x5~x7, x28~x31)， 作为临时寄存器使用，在被调函数中可以随意使用无需保存。
s0~s11(x8~x9, x18~x27)， 作为临时寄存器使用，被调函数保存后才能在被调函数中使用。 被调用者保存。

### RustSBI

SBI 是 RISC-V 的一种底层规范，RustSBI 是它的一种实现。 操作系统内核与 RustSBI 的关系有点像应用与操作系统内核的关系，后者向前者提供一定的服务。只是SBI提供的服务很少， 比如关机，显示字符串等。

### 应用程序执行

#### 启动

rust编译器需要入口函数 _start()来对环境进行一些初始化
使用QEMU 软件 qemu-system-riscv64 来模拟 RISC-V 64 计算机。加载内核程序的命令为

```shell
qemu-system-riscv64 \
            -machine virt \
            -nographic \
            -bios $(BOOTLOADER) \
            -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA)
```

-device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) 表示硬件内存中的特定位置 $(KERNEL_ENTRY_PA) 放置了操作系统的二进制代码 $(KERNEL_BIN) 。 

$(KERNEL_ENTRY_PA) 的值是 0x80200000
当虚拟计算机通电后，CPU 的其它通用寄存器清零，而 PC 会指向 0x1000 的位置，这里有固化在硬件中的一小段引导代码， 它会很快跳转到 0x80000000 的 RustSBI 处。 RustSBI完成硬件初始化后，会跳转到 $(KERNEL_BIN) 所在内存位置 0x80200000 处， 执行操作系统的第一条指令。

#### 设置内存布局

正如上述所说，pc会跳转到0x80200000执行第一条命令，因此可以通过 **链接脚本** (Linker Script) 调整链接器的行为，使得最终生成的可执行文件的内存布局符合我们的预期。修改 Cargo 的配置文件来使用我们自己的链接脚本 os/src/linker.ld

#### 起始程序

计算机执行的起始程序放在entry.asm中，即_start代码段，将依据链接脚本被放在 BASE_ADDRESS 处。除此外，该汇编代码还申请了操作系统的栈空间，被.bss.stack，链接脚本标识了它的空间位置
我们需要在 main.rs 中嵌入这些汇编代码并声明应用入口 rust_main

## 批处理系统

### Rust知识

#[macro_use]：这是一个Rust属性，它表示接下来要导入的库包含宏，这些宏应该在编译时被包含进来，以便在其他地方使用。

extern crate user_lib;：这是Rust语言的一部分，它表示我们正在导入一个外部库，这个库的名字是user_lib。在Rust中，每个库或模块都被称为一个crate。通过使用extern crate语句，我们可以导入并链接到外部的crate。这样我们就可以在我们的代码中使用这个库中的功能了。

### 汇编知识

CSRW指令：CSRW用于改变状态寄存器（Status Register）中的某个字段的值。通常，这个寄存器包含了重要的状态信息，例如溢出标志、零标志、符号标志等。

ADDI指令：ADDI (Add Immediate): ADDI是一种加法指令，它将一个立即数（即一个直接编码在指令中的数）添加到另一个值。例如，ADD I3, R1, 4 会将立即数4加到R1寄存器的值上，然后将结果存储在I3寄存器中。

### 特权级切换

特权级切换是由软硬件协同来完成的
trap时硬件会自动完成：

- sstatus 的 SPP 字段会被修改为 CPU 当前的特权级（U/S）。
- sepc 会被修改为 Trap 处理完成后默认会执行的下一条指令的地址。
- scause/stval 分别会被修改成这次 Trap 的原因以及相关的附加信息。
- CPU 会跳转到 stvec 所设置的 Trap 处理入口地址，并将当前特权级设置为 S ，然后从Trap 处理入口地址处开始执行。
- 当 CPU 完成 Trap 处理准备返回的时候，需要通过一条 S 特权级的特权指令 sret 来完成

而对于软件：
我们会在批处理操作系统中添加一段汇编代码，实现从用户栈切换到内核栈，并在内核栈上保存应用程序控制流的寄存器状态。

## 多道程序与分时多任务

### 协作式和分时抢占式

协作式操作系统是等待应用程序主动放弃CPU，调用sys_yield交出CPU使用权。
抢占式操作系统是任务随时都有可能被切换出去
对于某个处理器核而言， 陷入 与发起 陷入 的指令执行是 同步 (Synchronous) 的， 陷入被触发的原因一定能够追溯到某条指令的执行；而中断则 异步 (Asynchronous) 于当前正在进行的指令，也就是说中断来自于哪个外设以及中断如何触发完全与处理器正在执行的当前指令无关。

### 任务切换

任务切换不涉及特权级切换，它的一部分工作是由编译器帮忙完成的，它对应用是透明的。事实上，它是来自两个不同应用的 Trap 执行流之间的切换。当一个应用 Trap 到 S 模式的操作系统中进行进一步处理的时候，其 Trap 执行流可以调用一个特殊的 __switch 函数。

这个函数表面上就是一个普通的函数调用：在 __switch 返回之后，将继续从调用该函数的位置继续向下执行。但是其间却隐藏着复杂的执行流切换过程。具体来说，调用 __switch 之后直到它返回前的这段时间，原 Trap 执行流会先被暂停并被切换出去， CPU 转而运行另一个应用的 Trap 执行流。之后在时机合适的时候，原 Trap 执行流才会从某一条 Trap 执行流（很有可能不是它之前切换到的那一条）切换回来继续执行并最终返回。不过，从实现的角度讲， __switch 和一个普通的函数之间的差别仅仅是它会换栈